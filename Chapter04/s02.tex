\section{Processamento di base}
I dati catturati dal sensore, dopo che sono stati ricevuti, devono essere memorizzati per poter estrarre informazioni utili. Per fare questo, il package \texttt{com.dosse.openldat.processing} fornisce dei buffer e alcuni filtri per rendere più facile l'analisi che in seguito sarà svolta dal codice dei test.

\subsection{Buffer}
L'obiettivo dei buffer in questa applicazione è quello di memorizzare gli ultimi $N$ sample ricevuti, così da poterli analizzare in seguito, senza limiti di tempo.\\
Nel package \texttt{com.dosse.openldat.processing.buffers} vengono forniti due tipi di buffer e l'interfaccia generica per i buffer, che ora saranno discussi in dettaglio.

Nota: poiché tutti i dati ricevuti dal dispositivo sono numeri interi, i buffer sono pensati per memorizzare solo quelli, non fanno uso di generics.

\subsubsection{IBuffer}
L'interfaccia \texttt{IBuffer} definisce i metodi che tutti i buffer devono implementare.

\paragraph{Metodi da implementare:}\begin{itemize}
	\item \texttt{public void add(int val)}: aggiunge un singolo intero al buffer
	\item \texttt{public void add(int[] data)}: aggiunge un array di interi al buffer
	\item \texttt{public int[] getData()}: ritorna il contenuto attuale del buffer in maniera sicura (rispettando l'incapsulamento e in modo thread-safe)
	\item \texttt{public int[] getDataUnsafe()}: ritorna il contenuto attuale del buffer in maniera insicura (non rispetta l'incapsulamento e non è thread safe)
	\item \texttt{public int getSize()}: ritorna la dimensione del buffer, ossia quanti interi può contenere il buffer prima di sovrascrivere dei dati
	\item \texttt{public boolean isFilled()}: ritorna \texttt{true} se il buffer è pieno, ossia se sono già stati aggiunti abbastanza dati per evitare che ci siano celle vuote chiamando \texttt{getData}
\end{itemize}

\subsubsection{CircularBuffer}
Questa classe implementa una variante di un buffer circolare che permette di memorizzare gli ultimi $N$ sample aggiunti al buffer, con operazioni di aggiunta e lettura del buffer molto veloci.\\
Nonostante il nome, non è un buffer circolare in senso stretto, poiché il puntatore di scrittura e di lettura coincidono, ma questo è ciò di cui abbiamo bisogno per realizzare l'applicazione e velocizza notevolmente il codice.\\
Tutte le operazioni di questa classe utilizzano i metodi di copia di memoria del sistema anziché dei cicli, migliorando notevolmente le prestazioni.

La classe è thread-safe.

\paragraph{Costruttori:}\begin{itemize}
	\item \texttt{public CircularBuffer(int size)}: inizializza un buffer circolare di dimensione \texttt{size}
\end{itemize}

\paragraph{Metodi pubblici:}\begin{itemize}
	\item \texttt{public void add(int val)}: aggiunge un singolo intero al buffer. Se è pieno, viene sovrascritto il valore più vecchio
	\item \texttt{public void add(int[] data)}: aggiunge un array di interi al buffer. Se è pieno, vengono sovrascritti i valori più vecchi
	\item \texttt{public int[] getData()}: ritorna il contenuto attuale del buffer in maniera sicura (rispettando l'incapsulamento e in modo thread-safe)
	\item \texttt{public int[] getDataUnsafe()}: non supportato su un buffer circolare, esegue semplicemente \texttt{getData}
	\item \texttt{public int[] getInternalBuffer()}: ritorna l'array usato internamente per memorizzare i dati. I dati potrebbero non essere in ordine
	\item \texttt{public int getSize()}: ritorna la dimensione del buffer, ossia quanti interi può contenere il buffer prima di sovrascrivere dei dati
	\item \texttt{public boolean isFilled()}: ritorna \texttt{true} se il buffer è pieno, ossia se sono già stati aggiunti abbastanza dati per evitare che ci siano celle vuote chiamando \texttt{getData}
\end{itemize}

\subsubsection{ArrayBuffer}
Questa è implementa un buffer costante (non è possibile aggiungere nulla). Si tratta di una classe di utilità, utilizzata quando serve avere un array sotto forma di buffer.

La classe è thread-safe.

\paragraph{Costruttori:}\begin{itemize}
	\item \texttt{public ArrayBuffer(int[] data)}: inizializza il buffer con l'array di dati fornito. Nota: i dati non vengono copiati, ma solo il riferimento, per cui è possibile alterare il contenuto di questo buffer esternamente. Questo è voluto ed è utilizzato nella GUI
\end{itemize}

\paragraph{Metodi pubblici:}\begin{itemize}
	\item \texttt{public void add(int val)}: non supportato, lancia una \texttt{UnsupportedOperationException}
	\item \texttt{public void add(int[] data)}: non supportato, lancia una \texttt{UnsupportedOperationException}
	\item \texttt{public int[] getData()}: ritorna una copia dell'array \texttt{data} con cui è stato inizializzato il buffer
	\item \texttt{public int[] getDataUnsafe()}: ritorna l'array \texttt{data} con cui è stato inizializzato il buffer (riferimento)
	\item \texttt{public int getSize()}: ritorna la dimensione del buffer, ossia la dimensione dell'array \texttt{data} con cui è stato inizializzato
	\item \texttt{public boolean isFilled()}: ritorna sempre \texttt{true}
\end{itemize}

\subsection{Filtri}
Il package \texttt{com.dosse.openldat.processing.filters} contiene alcuni filtri che sono usati per semplificare l'analisi dei dati raccolti. A tutti gli effetti, un filtro non è altro che un tipo speciale di buffer, che però esegue un qualche tipo di processamento sui dati che gli vengono inseriti.

\subsubsection{FFTFilter}
Questa classe implementa un filtro che permette di inserire dati nel dominio del tempo (sample) e ottenere una rappresentazione degli stessi dati nel dominio di frequenza utilizzando una FFT (Fast Fourier Transform). La trasformazione viene eseguita dalla libreria jTransforms, ma prima viene applicata ai dati una funzione di windowing di Blackman-Harris, per generare dati più puliti. Per velocizzare l'esecuzione, l'FFT non viene eseguita ad ogni sample aggiunto, ma solo nel momento in cui vengono richiesti i dati.

\paragraph{Costruttori:}\begin{itemize}
	\item \texttt{public FFTFilter(int size)}: inizializza il filtro su un buffer circolare di dimensione \texttt{size}, che deve essere una potenza di 2 (requisito dell'FFT)
\end{itemize}

\paragraph{Metodi pubblici:} \begin{itemize}
	\item \texttt{public void add(int val)}: aggiunge un singolo intero al buffer. Se è pieno, viene sovrascritto il valore più vecchio
	\item \texttt{public void add(int[] data)}: aggiunge un array di interi al buffer. Se è pieno, vengono sovrascritti i valori più vecchi
	\item \texttt{public int[] getData()}: ritorna il contenuto attuale del buffer, ma nel dominio della frequenza. Ogni valore nell'array ritornato è un bin dell'FFT e il suo valore indica la potenza del segnale in quel bin. Per conoscere la frequenza a cui corrisponde l'i-esimo bin, è sufficiente usare la seguente formula: $\frac{i}{size}*(\frac{sampleRate}{2})$
	\item \texttt{public int[] getDataUnsafe()}: non supportato su un buffer circolare, esegue semplicemente \texttt{getData}
	\item \texttt{public int[] getOriginalData()}: ritorna i dati inseriti nel buffer, nel dominio temporale
	\item \texttt{public int[] getInternalBuffer()}: ritorna l'array usato internamente per memorizzare i dati nel dominio temporale. I dati potrebbero non essere in ordine
	\item \texttt{public int getSize()}: ritorna la dimensione del buffer, ossia quanti interi può contenere il buffer prima di sovrascrivere dei dati
	\item \texttt{public boolean isFilled()}: ritorna \texttt{true} se il buffer è pieno, ossia se sono già stati aggiunti abbastanza dati per evitare che ci siano celle nel buffer
\end{itemize}

\subsubsection{RunningAverageSmoothingFilter}
Questa classe implementa un filtro che "leviga" i dati utilizzando una sorta di media mobile.

Il filtro funziona in questo modo: internamente viene mantenuto il valore di output corrente che chiamiamo $currentValue$, inizializzato a 0; ogni volta che viene aggiunto un nuovo sample $new$, si aggiorna in questo modo: $currentValue=smoothing*currentValue+(1-smoothing)*new$, dove $smoothing$ è un valore tra 0 e 1 e indica la resistenza che il filtro oppone a cambiare il valore (0 è istantaneo, 1 non cambia mai). Valori tipici per $smoothing$ sono molto vicini a 1.

La classe è thread-safe.

\paragraph{Costruttori:} \begin{itemize}
	\item \texttt{public RunningAverageSmoothingFilter(int size, double smoothing)}: inizializza il filtro su un buffer circolare di dimensione \texttt{size} e con il valore di \texttt{smoothing}
\end{itemize}

\paragraph{Metodi pubblici:} \begin{itemize}
	\item \texttt{public void add(int val)}: aggiunge un singolo intero al buffer. Se è pieno, viene sovrascritto il valore più vecchio. Quando viene aggiunto il primo sample, il valore di $currentValue$ viene inizializzato con quel valore
	\item \texttt{public void add(int[] data)}: aggiunge un array di interi al buffer. Se è pieno, vengono sovrascritti i valori più vecchi. Quando viene aggiunto il primo sample, il valore di $currentValue$ viene inizializzato con quel valore
	\item \texttt{public int[] getData()}: ritorna il contenuto attuale del buffer in maniera sicura (rispettando l'incapsulamento e in modo thread-safe)
	\item \texttt{public int[] getDataUnsafe()}: non supportato su un buffer circolare, esegue semplicemente \texttt{getData}
	\item \texttt{public int[] getInternalBuffer()}: ritorna l'array usato internamente per memorizzare i dati. I dati potrebbero non essere in ordine
	\item \texttt{public int getSize()}: ritorna la dimensione del buffer, ossia quanti interi può contenere il buffer prima di sovrascrivere dei dati
	\item \texttt{public boolean isFilled()}: ritorna \texttt{true} se il buffer è pieno, ossia se sono già stati aggiunti abbastanza dati per evitare che ci siano celle vuote chiamando \texttt{getData}
\end{itemize}

\subsubsection{PeakHoldFilter}
Questa classe implementa un filtro che mantiene i picchi del segnale dato in ingresso. Ogni sample in output generato dal filtro contiene il valore massimo di una finestra di sample inseriti precedentemente. Questa classe è particolarmente utile per elaborare segnali misurati su display con retroilluminazione PWM.

La classe è thread-safe.

\paragraph{Costruttori:}\begin{itemize}
	\item \texttt{public PeakHoldFilter(int size, int peakWindowSize)}: inizializza il filtro con una dimensione del buffer di \texttt{size} e una dimensione della finestra in cui ricercare il massimo di \texttt{peakWindowSize}
\end{itemize}

\paragraph{Metodi pubblici:}\begin{itemize}
	\item \texttt{public void add(int val)}: aggiunge un singolo intero al buffer. Se è pieno, viene sovrascritto il valore più vecchio
	\item \texttt{public void add(int[] data)}: aggiunge un array di interi al buffer. Se è pieno, vengono sovrascritti i valori più vecchi
	\item \texttt{public int[] getData()}: ritorna il contenuto attuale del buffer in maniera sicura (rispettando l'incapsulamento e in modo thread-safe)
	\item \texttt{public int[] getDataUnsafe()}: non supportato su un buffer circolare, esegue semplicemente \texttt{getData}
	\item \texttt{public int[] getInternalBuffer()}: ritorna l'array usato internamente per memorizzare i dati. I dati potrebbero non essere in ordine
	\item \texttt{public int getSize()}: ritorna la dimensione del buffer, ossia quanti interi può contenere il buffer prima di sovrascrivere dei dati
	\item \texttt{public boolean isFilled()}: ritorna \texttt{true} se il buffer è pieno, ossia se sono già stati aggiunti abbastanza dati per evitare che ci siano celle vuote chiamando \texttt{getData}
\end{itemize}

\paragraph{Metodi statici:}\begin{itemize}
	\item \texttt{public static int findBestWindowSize(int[] noisyData, int min, int max, int stepSize, int noiseThreshold)}: determina il valore minimo di \texttt{peakWindowSize} da utilizzare per far si che applicando il filtro sull'array \texttt{noisyData}, la differenza tra il valore minimo e massimo dopo il filtraggio sia inferiore a \texttt{noiseThreshold}. \texttt{min} e \texttt{max} permettono di restringere l'intervallo di ricerca del valore di \texttt{peakWindowSize} in quel range, a passi di \texttt{stepSize}. Ritorna -1 se i dati in input non sono validi
\end{itemize}

\subsection{Esempio di utilizzo}
Il seguente listato mostra un esempio di come è possibile acquisire un segnale dal dispositivo e filtrarlo. I grafici nelle figure \ref{fig:filters_example_original}, \ref{fig:filters_example_smooth} e \ref{fig:filters_example_peakHold} mostrano l'output dei filtri. Il segnale catturato è un LED con una PWM di circa 120Hz con piccoli movimenti del sensore per mostrare meglio il comportamento dei filtri.
\lstinputlisting[language=Java]{Chapter04/res/FiltersExample.java}
\begin{figure}[H]
	\centering
	\begin{tikzpicture}
		\begin{axis}[name=Segnale, xmin=0,xmax=8192,ymin=0,ymax=1023,width=.8\textwidth,xlabel=Sample,ylabel=Valore]
			\addplot[black] file{Chapter04/res/filters_example_original.txt};
		\end{axis}
	\end{tikzpicture}
	\begin{tikzpicture}
		\begin{axis}[name=Spettro, xmin=0,xmax=4000,ymin=0,ymax=150000,width=.8\textwidth,xlabel=Frequenza (Hz),ylabel=Potenza]
			\addplot[black] file{Chapter04/res/filters_example_fft.txt};
		\end{axis}
	\end{tikzpicture}
	\caption{Segnale originale e relativo spettro in frequenza. I picchi sono causati dalla frequenza della PWM}
	\label{fig:filters_example_original}
\end{figure}
\begin{figure}[H]
	\centering
	\begin{tikzpicture}
		\begin{axis}[name=Segnale, xmin=0,xmax=8192,ymin=0,ymax=1023,width=.8\textwidth,xlabel=Sample,ylabel=Valore]
			\addplot[gray] file{Chapter04/res/filters_example_original.txt};
			\addplot[red] file{Chapter04/res/filters_example_smooth.txt};
		\end{axis}
	\end{tikzpicture}
	\caption{Segnale originale (grigio), RunningAverageSmoothingFilter (rosso)}
	\label{fig:filters_example_smooth}
\end{figure}
\begin{figure}[H]
	\centering
	\begin{tikzpicture}
		\begin{axis}[name=Segnale, xmin=0,xmax=8192,ymin=0,ymax=1023,width=.8\textwidth,xlabel=Sample,ylabel=Valore]
			\addplot[gray] file{Chapter04/res/filters_example_original.txt};
			\addplot[red] file{Chapter04/res/filters_example_peakHold.txt};
		\end{axis}
	\end{tikzpicture}
	\caption{Segnale originale (grigio), PeakHoldFilter (rosso)}
	\label{fig:filters_example_peakHold}
\end{figure}
